# javascript

## 原型链

## 作用域&闭包

### 作用域

在我的理解中作用域就是变量访问的规则

举个栗子

```js
function out() {
  var a = 123;
  console.log(a); // 123
}
outFun2();
console.log(a); // a is not defined
```

上面的例子就可以体现作用域的作用了，变量 a 在 out 函数中声明，所以在全局作用域下取值会报错

> JavaScript 分为局部作用域和全局作用域（还有"块级作用域"，后面会说）

- 变量在函数内声明为局部作用域，只能被当前作用域和内层的作用域访问；
- 变量在全局声明则为全局作用域，能被任何地方访问；

js 中变量的访问规则：内层作用域可以访问外层作用域的变量，反之不行；
也就是说如果函数嵌套了函数，在最内部函数中访问某个变量时，会一层层往外访问声明的变量，层层访问就形成了作用域链；

var 声明赋值的变量会在当前的作用域内预解析导致变量提升，当执行到赋值语句再赋值

举个栗子

```js
function out() {
  console.log(a); // undefined
  var a = 123;
  console.log(a); // 123
}
outFun2();
```

所有末定义直接赋值的变量自动声明为拥有全局作用域

```js
function out() {
  a = 123;
}
outFun2();
console.log(a); // 123
```

原因也很简单，执行函数给 a 赋值时，会在作用域链上找定义 a 的作用域，一直访问到全局，也没有定义 a，于是 a 被定义在了 window 全局对象上，当我们访问 a 时就是访问的 window.a

我们现在知道函数会创建一个的作用域,但是块语句(if 条件语句或 for 循环语句)不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。
这里就会引申出一个经典的面试题

```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i);
  };
}
a[1](); // 10
```

这就是上面所说的,在块语句中定义的变量将保留在它们已经存在的作用域中,当我们调用 a[1]的时候 这个 i 其实就是最初在 for 中定义的 i,此时 for 循环执行完,i 已经是 10 了

怎么解决这个问题呢 我们可以通过自调用函数传参数的方式创建10个函数,形成自己的作用域,就不会访问到最外层for循环定的的i变量了

```js
var a = [];
for (var i = 0; i < 10; i++) {
  (function(i) {
    a[i] = function() {
      console.log(i);
    };
  })(i);
}
a[1](); // 1
```

说到这里,我们就可以引出"块级作用域"的概念了

> 块级作用域可通过在函数或者块语句(包括if,for)用es6的let和const来声明形成

let const将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：

- 声明的变量不会提升到代码块顶部(变量提升)
- 禁止重复声明相同的变量名

改造一下初始的for循环代码 将var换成let就能解决问题,每次循环let都会产生块级作用域,维护自身i的变量,防止污染


```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i);
  };
}
a[1](); // 1
```

### 作用域与执行上下文

许多人混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。
我们知道JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：

1. 解释阶段：

    - 词法分析
    - 语法分析
    - 作用域规则确定

2. 执行阶段：

    - 创建执行上下文
    - 执行函数代码
    - 垃圾回收

> JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是：
执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。
一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过,同一个作用域下，不同的调用会产生不同的执行上下文环境。

### 闭包

函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。

## new 操作符

1. 首先创建一个空的对象，空对象的**proto**属性指向构造函数的原型对象
2. 把上面创建的空对象赋值构造函数内部的 this，用构造函数内部的方法修改空对象
3. 如果构造函数返回一个非基本类型的值，则返回这个值，否则上面创建的对象
   function \_new(fn, ...arg) {
   const obj = Object.create(fn.prototype);
   const ret = fn.apply(obj, arg);
   return ret instanceof Object ? ret : obj;
   }

## 防抖

## 节流

## 继承

## promise

## 箭头函数
