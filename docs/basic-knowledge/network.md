# network

## Http 协议

特点

1. 灵活：HTTP 允许传输任意类型的数据对象。体现传输的形式多样性。

2. 无状态：每次连接都是独立无关的，默认不需要保留状态信息。

3. 无连接：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。

### http 报文结构

http1.1 的报文结构由四部分构成

- 起始行/状态行 + 头部 + 空行 + 实体

#### 起始行/状态行

请求报文的起始行由请求方法 + 路径 + http 版本

> GET /home HTTP/1.1

响应报文的起始行由 http 版本、状态码和描述

> HTTP/1.1 200 OK

#### 请求头/响应头

头部中包含许多字段,客户端和服务器根据这些字段来做各种处理
例如:
Content-Encoding 指定 gzip 压缩
Content-Type 指定内容的格式
Cache-Control 控制缓存的方式
......

#### 空行

空行用来区分开头部和实体。在头部中间故意加一个空行,那么空行后的内容全部被视为实体。

#### 请求体/响应体

请求体/响应体 就是数据传输的主要载体

### http 请求方法

http/1.1 规定了以下请求方法(注意，都是大写):

- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源
- ONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

常见问题 get 与 post 的区别?

1. 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
2. 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
3. 从体积的角度，GET 传送数据的大小为浏览器地址栏接受的上限，而 POST 没有限制。
4. 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
5. 从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)
6. 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

### http 状态码

罗列一些常见的状态码

1xx: 表示目前是协议处理的中间状态。

- 100 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
- 101 请求者已要求服务器切换协议，服务器已确认并准备切换。

2xx: 表示成功状态。

- 200 （最好看也是最常见的成功状态码）

3xx: 重定向状态，资源位置发生变动，需要重新请求。

- 301 （永久移动） 请求的网页已永久移动到新位置，默认会做缓存优化，搜索引擎会抓取新内容并将旧的网址交换为重定向之后的网址。
- 302 （临时移动） 请求的网页临时移动到新位置，默认不会缓存优化，搜索引擎会抓取新内容并将保留旧地址。
- 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

4xx: 请求报文有误。

- 400 Bad Request: 错误的请求。
- 403 Forbidden: 服务器拒绝访问，比如法律禁止、信息敏感。
- 404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
- 405 Method Not Allowed: 请求方法不被服务器端允许。
- 406 Not Acceptable: 资源无法满足客户端的条件。

5xx: 服务器端错误。

- 500 Internal Server Error: 服务器出错。
- 501 Not Implemented: 表示客户端请求的功能还不支持。
- 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错。
- 503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。

### http 的缺点

#### 无状态

所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

#### 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。
这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。

#### 队头阻塞问题

当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，造成队头阻塞问题。

- 针对 http 的这些特点，下面会引申出对应的知识点

## cookie & session

HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。那么客户端怎么向服务端告知自身状态呢？
Cookie 和 Seesion 的配合就解决了这个问题。

### Cookie

Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie。

- 生存周期
  Cookie 的有效期可以通过 Expires 和 Max-Age 两个属性来设置。

1. Expires 即设置过期时间 2
2. Max-Age 从浏览器收到报文开始计算有效时间区间。
   若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

- 作用域
  关于作用域也有两个属性: Domain 和 path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。

- Cookie 的缺点

1. 容量缺陷。Cookie 的体积上限只有 4KB，只能用来存储少量的信息。

2. 性能缺陷。Cookie 紧跟域名，每次请求都会携带上完整的 Cookie，不需要 cookie 的情况下会造成性能浪费的，可以通过 Domain 和 Path 指定作用域来解决。

3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 true 的情况下，Cookie 信息可以防止 JS 脚本来读取。

### Session

session 机制是一种服务器端的机制，主要用于来保存信息。服务端要为特定的用户创建了特定的 Session，用于标识这个用户；Session 是保存在服务端的，有一个唯一标识（sessionId）。在服务端保存 Session 的方式不限于内存、数据库等

### 实现状态保持

每次 HTTP 请求的时候，客户端都会发送相应的 Cookie 信息到服务端，第一次访问时，服务器创建 Session 对象并生成一个 seesion ID 并在 HTTP 协议中告诉客户端，需要在 Cookie 里面记录 Session ID，以后每次请求把这个 session ID 发送到服务器，服务器通过这个标识能够知道用户的状态信息，实现了状态保持。

## https

HTTP 是明文传输的协议，传输的数据会对外界暴露不安全，会被第三方窃取或者篡改，也就是常说的中间人攻击，由此产生了 HTTPS，其实它并不是一个新的协议，而是在 HTTP 下面增加了一层 SSL/TLS 协议，HTTP 与 TCP 不会直接通信，由一个 SSL/TLS 协议作为中间层进行加密，将加密后的数据包传给 TCP，TCP 将数据包解密才能传给 HTTP。

### https 加密

#### 对称加密和非对称加密

首先需要理解对称加密和非对称加密的概念：
对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。
非对称加密：拥有公钥和私钥，用公钥加密的数据只有用对应的私钥才能解密，反之一样；

#### 添加数字证书

尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。

于是 HTTPS 在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。

为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫 CA(Certificate Authority), 认证通过后 CA 会给服务器颁发数字证书。

这个数字证书有两个作用:

1. 服务器向浏览器证明自己的身份。
2. 把公钥传给浏览器。

#### 证书伪造

证书是用于证明服务器身份的，设想一下，如果攻击者在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，得到明文传输的 Key1、Key2 和 Pre-Master-Key，从而窃取客户端和服务端的通信数据；使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

#### 验证过程

通过哈希摘要算法来验证证书合法性可以有效防止证书伪造，将服务端的证书信息通过这个 hash 算法生成一个摘要，用 CA 的私钥加密后把加密后的数字签名和对应的公钥传给客户端。客户端拿到数字证书后，用公钥来解密数字签名，生成摘要。与数字证书上的摘要进行对比，如果相同则能确认服务端的身份，这也就是数字签名的原理。

![验证证书](../asserts/https1.jpg)

对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。这就形成了一条证书链；如图：

![证书链](../asserts/https2.png)

找到根级的 CA 后会和内置在操作系统当中的 CA 比对是否被信任。

#### 完整流程

结合以上的知识,我们根据下面的流程图描述一下完整过程:

![https加解密](../asserts/http3.jpg)

1. 首先客户端请求：

   - 发送 client_random、TLS 版本、加密套件列表等。

   client_random 是客户端生成的随机数，用于生成会话秘钥的一个参数。

   常见加密套件列表:

   > TLS_ECDHE_WITH_AES_128_GCM_SHA256

   意思是 TLS 握手过程中，使用 ECDHE 算法生成 pre_random(这个数后面会介绍)，128 位的 AES 算法进行对称加密，在对称加密的过程中使用主流的 GCM 分组模式，分组模式与对称加密相关（不太了解）。最后一个是哈希摘要算法，采用 SHA256 算法。

2. 服务端向客户端回应：

   - 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。

   - sever_random，是服务端生成的随机数，用于生成会话秘钥的一个参数。

   - 确认使用的加密方法，比如 RSA 公钥加密。

   - sever-params 用于生成第三个随机数 pre_random 的参数

   - 服务器证书（Certificate）。

3. 客户端回应

   - 实际上 TLS 握手是一个双向认证的过程，客户端有能力验证服务器的身份，那服务器自然也能验证客户端的身份，举个栗子：比如银行向客户提供的 u 盾，里面就包含了一张客户端证书，用于服务器来识别客户端的安全性。

   - 此时如果服务端需要对客户端进行验证，在客户端收到服务端的消息之后，首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。

   - 接着客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递 client_params 这个参数给服务器。在客户端通过 ECDHE 算法计算出 pre_random，其中传入两个参数:server_params 和 client_params。

   - 客户端现在拥有了 client_random、server_random 和 pre_random，接下来将这三个数通过一个伪随机数函数来计算出最终的会话秘钥。

4. 服务端回应

   - 服务端开始用 ECDHE 算法生成 pre_random，接着用和客户端同样的伪随机数函数生成最后的 secret,双方都会使用生成的会话秘钥传输数据。

## 浏览器缓存

合理的利用缓存可以改善用户体验，也可以降低服务器的承载压力，作为前端开发了解缓存机制是很有必要的

那么浏览器是如何判断资源是否需要缓存以及缓存资源的过程是怎样的呢？

浏览器第一次向服务器发起该请求后拿到结果后，会将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。之后的缓存流程就是根据响应头的字段来做相应的处理。
浏览器中的缓存作用分为两种情况：强缓存和协商缓存，两者的区别就是是否需要重新发送 HTTP 请求。

### 强缓存

强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

![cache](../asserts/cache2.png)

#### Expires

在 HTTP/1.0 时期使用的是 Expires，语义化的理解其实就是设置过期时间，在此之前的所有数据都从缓存中获取。比如设置在4月1号8点之前都是直接从缓存中读数据：

```js
Expires: Wed, 1 Apr 2020 08:00:00 GMT
```

#### Cache-Control

Cache-Control 通过请求头或者响应头中设置不同属性来设置缓存条件：

![cache-control](../asserts/cache3.png)

- public和private的区别在于代理服务器是否可以缓存资源

- no-cache其实并不是不做缓存，只是不希望通过cache-control来做前置判断，而是走协商缓存

- no-store才是表示浏览器不会走缓存

- max-stale表示能接受的最大过期时间。如果没有指定，说明浏览器愿意接收过期任意时长的资源

- min-fresh指令和max-stale功能类似，要求缓存服务器返回至少还未过指定时间的缓存资源。

::: tip
Cache-Control优先级高于Expires，另外强缓存并不会关心服务器端文件是否已经更新，这会导致服务器资源更新，而前端加载文件并不是服务器端最新的内容，为了解决这个问题就需要引入协商缓存策略。
:::

### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

浏览器在第一次访问资源时，服务器返回资源的同时，在响应头中添加 Last-Modified和ETag，这两者就是提到的缓存标识

![cache-control](../asserts/cache4.png)

#### Last-Modified

表示最后修改时间。当进入协商缓存时会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的If-Modified-Since的字段后，与服务器中该资源的最后修改时间作对比:

如果请求头中的这个值小于最后修改时间，返回新的资源，否则返回304，告诉浏览器直接用缓存；

#### ETag

ETag 是服务器根据当前文件的内容，给文件生成的唯一标识（类似于webpack打包生成文件的hash值），只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。

浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:如果两者不同，返回新的资源否则返回304，告诉浏览器直接用缓存。

#### 两者的区别

在精准度上，ETag优于Last-Modified。ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 在一些特殊的情况并不能准确感知资源变化，举个栗子：

1. 虽然编辑了资源文件，但是文件内容并没有更改；
2. Last-Modified 能够感知的单位时间是秒，如果文件在1秒内改变了多次时并不会被捕捉到；

在性能上，Last-Modified优于ETag，Last-Modified仅仅记录时间点，而 Etag需要根据文件的具体内容生成哈希值。

::: tip
另外，如果两种方式都支持的话，服务器会优先考虑ETa
:::

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

## 跨域
